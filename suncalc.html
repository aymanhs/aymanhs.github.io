<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sun Position & Shadow Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- SunCalc -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.9.0/suncalc.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0f172a;
        }

        #canvas-container {
            width: 100%;
            height: 60vh;
            display: block;
        }

        .glass-panel {
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(8px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Custom slider styling */
        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 24px;
            width: 24px;
            border-radius: 50%;
            background: #fbbf24;
            cursor: pointer;
            margin-top: -10px;
            box-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #475569;
            border-radius: 2px;
        }
    </style>
</head>

<body class="text-slate-200 font-sans">

    <!-- 3D Visualization Area -->
    <div id="canvas-container" class="relative">
        <div class="absolute top-2 left-2 md:top-4 md:left-4 pointer-events-auto z-10 max-w-[calc(100vw-5rem)]">
            <h1 class="text-lg md:text-2xl font-bold text-white drop-shadow-md">Sun Tracker</h1>
            <p id="location-status"
                class="text-xs md:text-sm text-emerald-400 font-medium flex items-center gap-1 md:gap-2">
                <span class="animate-pulse">‚óè</span> Locating...
            </p>
            <select id="city-selector"
                class="mt-1 md:mt-2 px-2 md:px-3 py-1 bg-slate-800/90 text-white text-xs rounded border border-slate-600 hover:border-slate-500 cursor-pointer focus:outline-none focus:border-emerald-400 w-full md:w-auto">
                <option value="browser">üìç Use Browser Location</option>
                <option value="26.0667,50.5577">üáßüá≠ Bahrain</option>
                <option value="78.2232,15.6267">üá∏üáØ Longyearbyen (North)</option>
                <option value="51.5074,-0.1278">üá¨üáß London</option>
                <option value="40.7128,-74.0060">üá∫üá∏ New York City</option>
                <option value="34.0522,-118.2437">üá∫üá∏ Los Angeles</option>
                <option value="35.6762,139.6503">üáØüáµ Tokyo</option>
                <option value="48.8566,2.3522">üá´üá∑ Paris</option>
                <option value="-33.8688,151.2093">üá¶üá∫ Sydney</option>
                <option value="55.7558,37.6173">üá∑üá∫ Moscow</option>
                <option value="39.9042,116.4074">üá®üá≥ Beijing</option>
                <option value="19.4326,-99.1332">üá≤üáΩ Mexico City</option>
                <option value="25.2048,55.2708">üá¶üá™ Dubai</option>
                <option value="21.3099,39.8208">üá∏üá¶ Mecca</option>
                <option value="1.3521,103.8198">üá∏üá¨ Singapore</option>
                <option value="-23.5505,-46.6333">üáßüá∑ S√£o Paulo</option>
                <option value="52.5200,13.4050">üá©üá™ Berlin</option>
                <option value="-54.8019,-68.3030">üá¶üá∑ Ushuaia (South)</option>
            </select>
        </div>
        <div id="north-indicator"
            class="absolute top-2 right-2 md:top-4 md:right-4 text-right cursor-pointer hover:opacity-80 transition-opacity"
            title="Click for top view">
            <div class="text-xs text-slate-400 uppercase tracking-wider">North</div>
            <div
                class="w-8 h-8 border-2 border-slate-600 rounded-full flex items-center justify-center bg-slate-800/50">
                <div class="w-0.5 h-4 bg-red-500 rounded-full transform -translate-y-1"></div>
            </div>
        </div>
        <!-- Instructions overlay -->
        <div class="absolute bottom-4 right-4 pointer-events-none opacity-50 text-xs text-white text-right">
            Drag to rotate & tilt ‚Ä¢ Scroll to Zoom
        </div>
    </div>

    <!-- Controls & Data Panel -->
    <div class="glass-panel fixed bottom-0 left-0 w-full h-[40vh] flex flex-col p-4 md:p-6 overflow-y-auto">

        <!-- Time Speed Slider Control -->
        <div class="w-full max-w-3xl mx-auto mb-6">
            <div class="flex justify-between items-end mb-2">
                <div>
                    <div class="text-xs text-slate-400 uppercase tracking-widest">Simulation Time</div>
                    <div id="display-time" class="text-xl md:text-3xl font-bold text-white font-mono">--</div>
                </div>
                <div class="flex gap-2">
                    <button id="reset-btn"
                        class="px-3 py-1 bg-indigo-600 hover:bg-indigo-500 text-white text-xs font-bold rounded shadow transition-colors">
                        JUMP TO NOW
                    </button>
                </div>
            </div>
            <input type="range" id="time-slider" min="-10" max="10" value="0" step="1" class="w-full">
            <div class="flex justify-between text-xs text-slate-500 mt-1">
                <span>
                    << Rewind</span>
                        <span>Stop</span>
                        <span>Forward >></span>
            </div>
        </div>

        <!-- Date Speed Slider Control -->
        <div class="w-full max-w-3xl mx-auto mb-6">
            <div class="flex justify-between items-end mb-2">
                <div class="flex justify-between items-end w-full">
                    <div>
                        <div class="text-xs text-slate-400 uppercase tracking-widest">Date Speed</div>
                    </div>
                    <button id="today-btn"
                        class="px-3 py-1 bg-indigo-600 hover:bg-indigo-500 text-white text-xs font-bold rounded shadow transition-colors">
                        TODAY
                    </button>
                </div>
            </div>
            <input type="range" id="date-slider" min="-10" max="10" value="0" step="1" class="w-full">
            <div class="flex justify-between text-xs text-slate-500 mt-1">
                <span>
                    << Prev Year</span>
                        <span>Stop</span>
                        <span>Next Year >></span>
            </div>
        </div>

        <!-- Data Grid -->
        <div class="grid grid-cols-3 sm:grid-cols-4 lg:grid-cols-8 gap-2 w-full max-w-7xl mx-auto">
            <!-- Card for Fajr -->
            <div id="card-fajr"
                class="bg-slate-800/50 p-2 rounded-lg border border-slate-700 cursor-pointer hover:bg-slate-700/50 transition-colors">
                <div class="text-xs text-slate-400 uppercase">Fajr</div>
                <div id="val-fajr" class="text-lg font-semibold text-cyan-300">--:--</div>
            </div>

            <!-- Card for Dawn -->
            <div id="card-dawn"
                class="bg-slate-800/50 p-2 rounded-lg border border-slate-700 cursor-pointer hover:bg-slate-700/50 transition-colors">
                <div class="text-xs text-slate-400 uppercase">Dawn</div>
                <div id="val-dawn" class="text-lg font-semibold text-sky-300">--:--</div>
            </div>

            <!-- Card 1: Sunrise -->
            <div id="card-sunrise"
                class="bg-slate-800/50 p-2 rounded-lg border border-slate-700 cursor-pointer hover:bg-slate-700/50 transition-colors">
                <div class="text-xs text-slate-400 uppercase">Sunrise</div>
                <div id="val-sunrise" class="text-lg font-semibold text-amber-300">--:--</div>
            </div>

            <!-- Card 2: Solar Noon -->
            <div id="card-noon"
                class="bg-slate-800/50 p-2 rounded-lg border border-slate-700 cursor-pointer hover:bg-slate-700/50 transition-colors">
                <div class="text-xs text-slate-400 uppercase">Solar Noon</div>
                <div id="val-noon" class="text-lg font-semibold text-yellow-400">--:--</div>
            </div>

            <!-- Card 3: Sunset -->
            <div id="card-sunset"
                class="bg-slate-800/50 p-2 rounded-lg border border-slate-700 cursor-pointer hover:bg-slate-700/50 transition-colors">
                <div class="text-xs text-slate-400 uppercase">Sunset</div>
                <div id="val-sunset" class="text-lg font-semibold text-orange-400">--:--</div>
            </div>

            <!-- Card 5: Dusk -->
            <div id="card-dusk"
                class="bg-slate-800/50 p-2 rounded-lg border border-slate-700 cursor-pointer hover:bg-slate-700/50 transition-colors">
                <div class="text-xs text-slate-400 uppercase">Dusk</div>
                <div id="val-dusk" class="text-lg font-semibold text-indigo-300">--:--</div>
            </div>

            <!-- Card 6: Ishaa -->
            <div id="card-ishaa"
                class="bg-slate-800/50 p-2 rounded-lg border border-slate-700 cursor-pointer hover:bg-slate-700/50 transition-colors">
                <div class="text-xs text-slate-400 uppercase">Ishaa</div>
                <div id="val-ishaa" class="text-lg font-semibold text-purple-400">--:--</div>
            </div>

            <!-- Card 7: Elevation -->
            <div class="bg-slate-800/50 p-2 rounded-lg border border-slate-700">
                <div class="text-xs text-slate-400 uppercase">Elevation</div>
                <div id="val-elevation" class="text-lg font-semibold text-blue-300">--¬∞</div>
                <div id="val-azimuth" class="text-[10px] text-slate-500">Azimuth: --¬∞</div>
            </div>
        </div>
    </div>

    <script>
        // --- Global State ---
        // Default to London if location fails
        let userLat = 51.5074;
        let userLon = -0.1278;
        let isManualMode = false;
        let currentDate = new Date();
        let sunPathLine = null;
        let sunDirectionArrow = null;
        let seasonLine = null;
        let moonMesh = null;
        let moonPathLine = null;
        let sunGlow = null;

        // Speed Control State
        let timeSpeed = 0;
        let dateSpeed = 0;
        let lastFrameTime = 0;
        let dateAccumulator = 0;

        // Config
        const SUN_ORBIT_RADIUS = 25; // Reduced from 50 to bring sun closer

        // --- DOM Elements ---
        const locationStatus = document.getElementById('location-status');
        const citySelector = document.getElementById('city-selector');
        const timeSlider = document.getElementById('time-slider');
        const displayTimeEl = document.getElementById('display-time');
        const resetBtn = document.getElementById('reset-btn');
        const northIndicator = document.getElementById('north-indicator');
        const dateSlider = document.getElementById('date-slider');
        const todayBtn = document.getElementById('today-btn');

        // Data Elements
        const elSunrise = document.getElementById('val-sunrise');
        const elNoon = document.getElementById('val-noon');
        const elSunset = document.getElementById('val-sunset');
        const elElevation = document.getElementById('val-elevation');
        const elAzimuth = document.getElementById('val-azimuth');
        const elDawn = document.getElementById('val-dawn');
        const elDusk = document.getElementById('val-dusk');
        const elIshaa = document.getElementById('val-ishaa');
        const elFajr = document.getElementById('val-fajr');

        // Clickable cards
        const cardSunrise = document.getElementById('card-sunrise');
        const cardNoon = document.getElementById('card-noon');
        const cardSunset = document.getElementById('card-sunset');
        const cardDawn = document.getElementById('card-dawn');
        const cardDusk = document.getElementById('card-dusk');
        const cardIshaa = document.getElementById('card-ishaa');
        const cardFajr = document.getElementById('card-fajr');

        // Layer constants
        const SCENE_LAYER = 0;
        const MOON_LAYER = 1;

        // --- Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color('#0f172a');
        // FOG DISABLED

        const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.layers.enableAll();

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // --- Expanded Camera Controls ---
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraAzimuth = 0; // Horizontal rotation
        let cameraElevation = 0.5; // Vertical angle (radians)
        let cameraRadius = 45; // Start a bit further back to see the scene

        // Initial Position
        updateCameraPosition();

        container.addEventListener('mousedown', (e) => isDragging = true);
        container.addEventListener('mouseup', (e) => isDragging = false);
        container.addEventListener('mouseleave', () => isDragging = false);

        container.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.offsetX - previousMousePosition.x;
                const deltaY = e.offsetY - previousMousePosition.y;

                // Adjust angles
                cameraAzimuth -= deltaX * 0.01;
                cameraElevation += deltaY * 0.01;

                // Clamp vertical angle
                cameraElevation = Math.max(0.01, Math.min(Math.PI / 2, cameraElevation));

                updateCameraPosition();
            }
            previousMousePosition = { x: e.offsetX, y: e.offsetY };
        });

        // Mouse Wheel Zoom
        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            // Zoom speed
            const zoomSpeed = 0.05;
            // Adjust radius based on scroll delta
            cameraRadius += e.deltaY * zoomSpeed;
            // Clamp zoom - allow zooming out much further (up to 200)
            cameraRadius = Math.max(10, Math.min(200, cameraRadius));
            updateCameraPosition();
        });

        // Touch support with pinch-to-zoom
        let lastTouchDistance = null;

        container.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            } else if (e.touches.length === 2) {
                isDragging = false;
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
            }
        });
        container.addEventListener('touchend', () => {
            isDragging = false;
            lastTouchDistance = null;
        });
        container.addEventListener('touchmove', (e) => {
            if (e.touches.length === 1 && isDragging) {
                const deltaX = e.touches[0].clientX - previousMousePosition.x;
                const deltaY = e.touches[0].clientY - previousMousePosition.y;

                cameraAzimuth -= deltaX * 0.01;
                cameraElevation += deltaY * 0.01;
                cameraElevation = Math.max(0.01, Math.min(Math.PI / 2, cameraElevation));

                updateCameraPosition();
                previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            } else if (e.touches.length === 2 && lastTouchDistance !== null) {
                // Pinch to zoom
                e.preventDefault();
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                const delta = lastTouchDistance - distance;
                cameraRadius += delta * 0.1;
                // Clamp zoom - allow zooming out much further (up to 200)
                cameraRadius = Math.max(10, Math.min(200, cameraRadius));

                lastTouchDistance = distance;
                updateCameraPosition();
            }
        });

        function updateCameraPosition() {
            // Convert Spherical to Cartesian
            const y = cameraRadius * Math.sin(cameraElevation);
            const rXZ = cameraRadius * Math.cos(cameraElevation);
            const x = rXZ * Math.sin(cameraAzimuth);
            const z = rXZ * Math.cos(cameraAzimuth);

            camera.position.set(x, y, z);
            camera.lookAt(0, 2, 0);
        }

        // --- Scene Objects ---

        // 1. Ground - Beige
        const planeGeometry = new THREE.PlaneGeometry(100, 100);
        const planeMaterial = new THREE.MeshStandardMaterial({
            color: 0xe6d8ad, // Beige / Sand color
            roughness: 1.0,
            metalness: 0.0,
            transparent: true,
            opacity: 0.5
        });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        scene.add(plane);

        // 2. Grid Helper
        const gridHelper = new THREE.GridHelper(100, 50, 0x94a3b8, 0xcbd5e1);
        scene.add(gridHelper);

        // 3. North Arrow
        const dir = new THREE.Vector3(0, 0, -1);
        const origin = new THREE.Vector3(0, 0.1, 8);
        const length = 4;
        const hex = 0xef4444;
        const arrowHelper = new THREE.ArrowHelper(dir, origin, length, hex, 1, 0.5);
        scene.add(arrowHelper);

        // 3.5. Sun Direction Arrow
        sunDirectionArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0.1, 0), 15, 0xffff00, 2, 1);
        scene.add(sunDirectionArrow);

        // 3.6. Seasonal Line
        const seasonLineMat = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 5 });
        const seasonLineGeom = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-10, 0, 0), new THREE.Vector3(10, 0, 0)]);
        seasonLine = new THREE.Line(seasonLineGeom, seasonLineMat);
        scene.add(seasonLine);

        // 7. Moon Representation
        const moonGeometry = new THREE.SphereGeometry(1.2, 32, 32); // Slightly smaller than sun
        const moonMaterial = new THREE.MeshStandardMaterial({
            color: 0xbbbbbb, // A light grey color
            metalness: 0.1,
            roughness: 0.8
        });
        moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
        moonMesh.castShadow = false;
        moonMesh.receiveShadow = true;
        moonMesh.layers.set(MOON_LAYER);
        scene.add(moonMesh);

        // 4. The Long Box
        const boxHeight = 6;
        const boxGeometry = new THREE.BoxGeometry(1, boxHeight, 1);
        const boxMaterial = new THREE.MeshStandardMaterial({ color: 0xfbbf24 });
        const box = new THREE.Mesh(boxGeometry, boxMaterial);
        box.position.y = boxHeight / 2;
        box.castShadow = true;
        box.receiveShadow = true;
        scene.add(box);

        // 5. Sun Representation (Visual Sphere)
        const sunGeometry = new THREE.SphereGeometry(1.5, 32, 32); // Slightly smaller visual sun
        const sunMaterial = new THREE.MeshBasicMaterial({
            color: 0xffff00,
        });
        const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sunMesh);

        // 5.5 Sun Glow
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.4)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        const sunGlowMaterial = new THREE.SpriteMaterial({
            map: createGlowTexture(),
            color: 0xffff00,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        sunGlow = new THREE.Sprite(sunGlowMaterial);
        sunGlow.scale.set(8, 8, 1); // Larger than sun
        scene.add(sunGlow);

        // 6. Lighting

        // Ambient Light affects everything
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.05);
        scene.add(ambientLight);

        // Light for the main scene (ground, box)
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
        sunLight.layers.set(SCENE_LAYER);

        // Dedicated light for the moon that is always on
        const sunLightForMoon = new THREE.DirectionalLight(0xffffff, 1.0);
        sunLightForMoon.layers.set(MOON_LAYER);
        scene.add(sunLightForMoon);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;

        // Shadow camera size
        const d = 25;
        sunLight.shadow.camera.left = -d;
        sunLight.shadow.camera.right = d;
        sunLight.shadow.camera.top = d;
        sunLight.shadow.camera.bottom = -d;
        sunLight.shadow.bias = -0.0005;

        scene.add(sunLight);

        // --- Logic ---

        function getSunPositionVector(azimuth, altitude, radius) {
            // Convert Azimuth/Altitude to Cartesian X/Y/Z
            const x = radius * -Math.sin(azimuth) * Math.cos(altitude);
            const y = radius * Math.sin(altitude);
            const z = radius * Math.cos(azimuth) * Math.cos(altitude);
            return { x, y, z };
        }


        function getMoonVisualRadius(distance) {
            // Map distance (approx 360000 - 406000 km) to visual radius (10 - 40)
            // Strongly Exaggerated effect to cross the Sun's orbit (25)
            const minKm = 360000;
            const maxKm = 406000;
            const minRad = 10;
            const maxRad = 20;

            const t = (distance - minKm) / (maxKm - minKm);
            return THREE.MathUtils.lerp(minRad, maxRad, t);
        }

        function updateSunPath(date) {
            if (sunPathLine) {
                scene.remove(sunPathLine);
                sunPathLine.geometry.dispose();
                sunPathLine.material.dispose();
            }

            const points = [];
            const pathDate = new Date(date);
            pathDate.setHours(0, 0, 0, 0);

            for (let i = 0; i <= 24 * 4; i++) {
                const sunPos = SunCalc.getPosition(pathDate, userLat, userLon);
                const vec = getSunPositionVector(sunPos.azimuth, sunPos.altitude, SUN_ORBIT_RADIUS);
                points.push(new THREE.Vector3(vec.x, vec.y, vec.z));
                pathDate.setMinutes(pathDate.getMinutes() + 15);
            }

            const path = new THREE.CatmullRomCurve3(points);
            const tubularSegments = 256;
            const radius = 0.1; // Increased radius for thickness
            const radialSegments = 8;
            const tubeGeometry = new THREE.TubeGeometry(path, tubularSegments, radius, radialSegments, false);

            const colors = [];
            const colorAbove = new THREE.Color(0xffd700);
            const colorBelow = new THREE.Color(0x5a6a8a);
            const tubePoints = tubeGeometry.attributes.position.array;

            for (let i = 0; i < tubePoints.length; i += 3) {
                const y = tubePoints[i + 1];
                const color = (y >= 0) ? colorAbove : colorBelow;
                colors.push(color.r, color.g, color.b);
            }

            tubeGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.MeshBasicMaterial({ vertexColors: true });
            sunPathLine = new THREE.Mesh(tubeGeometry, material);
            scene.add(sunPathLine);
        }

        function updateSeasonLine(date) {
            if (!seasonLine) return;

            const latitudeInRad = userLat * Math.PI / 180;

            const noonTime = SunCalc.getTimes(date, userLat, userLon).solarNoon;
            const noonPos = SunCalc.getPosition(noonTime, userLat, userLon);

            // Robust Declination Calculation using Vector Dot Product
            // Pole Axis (North Celestial Pole)
            const poleAxis = new THREE.Vector3(0, Math.sin(latitudeInRad), -Math.cos(latitudeInRad));

            // Sun Vector at Noon
            // Note: getSunPositionVector returns {x,y,z}, we need THREE.Vector3
            const sv = getSunPositionVector(noonPos.azimuth, noonPos.altitude, 1.0);
            const sunVector = new THREE.Vector3(sv.x, sv.y, sv.z);

            // Declination is the angle between Sun and Celestial Equator.
            // Angle from Pole = acos( dot(Sun, Pole) )
            // Declination = 90 - Angle from Pole
            // sin(Dec) = cos(90-Dec) = dot(Sun, Pole)
            const sinDec = sunVector.dot(poleAxis);
            const declination = Math.asin(sinDec);

            // Calculate path circle radius and center
            const pathRadius = SUN_ORBIT_RADIUS * Math.cos(declination);
            const centerDist = SUN_ORBIT_RADIUS * Math.sin(declination);

            // Center position along the pole axis
            const centerPos = poleAxis.clone().multiplyScalar(centerDist);

            // The circle is perpendicular to the pole axis.
            // We need a vector perpendicular to the pole axis to define the start/end points.
            // Since poleAxis is in YZ plane, the X axis (1,0,0) is always perpendicular to it.
            const right = new THREE.Vector3(1, 0, 0);

            const startPoint = right.clone().multiplyScalar(-pathRadius).add(centerPos);
            const endPoint = right.clone().multiplyScalar(pathRadius).add(centerPos);

            seasonLine.geometry.setFromPoints([startPoint, endPoint]);
        }

        function updateMoonPath(date) {
            if (moonPathLine) {
                scene.remove(moonPathLine);
                moonPathLine.geometry.dispose();
                moonPathLine.material.dispose();
            }

            const points = [];
            const pathDate = new Date(date);
            pathDate.setHours(0, 0, 0, 0);

            for (let i = 0; i <= 24 * 4; i++) {
                const moonPos = SunCalc.getMoonPosition(pathDate, userLat, userLon);
                const radius = getMoonVisualRadius(moonPos.distance);
                let vec = getSunPositionVector(moonPos.azimuth, moonPos.altitude, radius);
                points.push(new THREE.Vector3(vec.x, vec.y, vec.z));
                pathDate.setMinutes(pathDate.getMinutes() + 15);
            }

            const path = new THREE.CatmullRomCurve3(points);
            const tubeGeometry = new THREE.TubeGeometry(path, 256, 0.05, 8, false);

            const colors = [];
            const colorAbove = new THREE.Color(0xeaeaea); // Light gray
            const colorBelow = new THREE.Color(0x444444); // Dark gray
            const tubePoints = tubeGeometry.attributes.position.array;

            for (let i = 0; i < tubePoints.length; i += 3) {
                const y = tubePoints[i + 1];
                const color = (y >= 0) ? colorAbove : colorBelow;
                colors.push(color.r, color.g, color.b);
            }

            tubeGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.MeshBasicMaterial({ vertexColors: true });
            moonPathLine = new THREE.Mesh(tubeGeometry, material);
            scene.add(moonPathLine);
        }

        function updateMoonPosition(date) {
            if (!moonMesh) return;
            const moonPos = SunCalc.getMoonPosition(date, userLat, userLon);
            const radius = getMoonVisualRadius(moonPos.distance);
            let vec = getSunPositionVector(moonPos.azimuth, moonPos.altitude, radius);
            moonMesh.position.set(vec.x, vec.y, vec.z);

            // Scale moon based on distance (closer = larger)
            // Base scale is 1.0. Exaggerate variation.
            // Ref distance = 384400 km
            const baseScale = 1.0;
            const scaleFactor = 384400 / moonPos.distance;
            // Exaggerate the scale difference: power of 5
            const finalScale = baseScale * Math.pow(scaleFactor, 5);
            moonMesh.scale.set(finalScale, finalScale, finalScale);
        }

        function updateSunPosition(date) {
            if (typeof SunCalc === 'undefined') return;

            const sunPos = SunCalc.getPosition(date, userLat, userLon);
            const azimuth = sunPos.azimuth;
            const altitude = sunPos.altitude;

            // Update UI
            const degreesAlt = (altitude * (180 / Math.PI)).toFixed(1);
            const degreesAz = (azimuth * (180 / Math.PI)).toFixed(1);
            elElevation.innerText = `${degreesAlt}¬∞`;
            elAzimuth.innerText = `Az: ${degreesAz}¬∞`;

            // Update sun direction arrow
            if (sunDirectionArrow) {
                sunDirectionArrow.setDirection(new THREE.Vector3(-Math.sin(azimuth), 0, Math.cos(azimuth)));
            }

            // Update 3D Sun & Light Position
            const pos = getSunPositionVector(azimuth, altitude, SUN_ORBIT_RADIUS);

            // Both sun lights track the sun's position
            sunLight.position.set(pos.x, pos.y, pos.z);
            sunLightForMoon.position.set(pos.x, pos.y, pos.z);
            sunMesh.position.set(pos.x, pos.y, pos.z);
            sunMesh.visible = true; // Sun is always visible

            sunGlow.position.set(pos.x, pos.y, pos.z);
            sunGlow.visible = true;

            // --- Sun, Light, & Background Color Logic ---
            const colorHorizon = new THREE.Color(0xff4500); // Orange/Red
            const colorNoon = new THREE.Color(0xffffff);    // White

            if (altitude < -0.1) {
                // Night
                sunLight.intensity = 0;
                sunMesh.material.color.set(0x5a6a8a); // Dark blue for night sun
                sunGlow.material.opacity = 0.1;
                sunGlow.material.color.set(0x5a6a8a);
                scene.background = new THREE.Color('#0f172a');

            } else if (altitude < 0.1) {
                // Twilight
                sunLight.intensity = 0.8;
                let t = THREE.MathUtils.clamp(altitude / 0.5, 0, 1);
                const sunColor = colorHorizon.clone().lerp(colorNoon, t);
                sunLight.color.copy(sunColor);
                sunMesh.material.color.copy(sunColor);
                sunGlow.material.color.copy(sunColor);
                sunGlow.material.opacity = 0.8;

                const bgNight = new THREE.Color('#0f172a');
                const bgDay = new THREE.Color('#38bdf8');
                const bgT = THREE.MathUtils.mapLinear(altitude, -0.1, 0.1, 0, 1);
                scene.background = bgNight.clone().lerp(bgDay, bgT);

            } else {
                // Day
                sunLight.intensity = 2.8;
                let t = THREE.MathUtils.clamp(altitude / 0.5, 0, 1);
                const sunColor = colorHorizon.clone().lerp(colorNoon, t);
                sunLight.color.copy(sunColor);
                sunMesh.material.color.copy(sunColor);
                sunGlow.material.color.copy(sunColor);
                sunGlow.material.opacity = 1.0;
                scene.background = new THREE.Color('#38bdf8');
            }

            // Update consolidated display
            const dateStr = date.toLocaleDateString([], { weekday: 'short', month: 'short', day: 'numeric' });
            const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            displayTimeEl.innerText = `${dateStr} ‚Ä¢ ${timeStr}`;
        }

        function updateSolarTimes(date) {
            if (typeof SunCalc === 'undefined') return;

            const times = SunCalc.getTimes(date, userLat, userLon);
            const formatTime = (d) => {
                if (!d || d.toString() === 'Invalid Date') return '--:--';
                return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
            };

            elFajr.innerText = formatTime(times.nightEnd);
            elDawn.innerText = formatTime(times.dawn);
            elSunrise.innerText = formatTime(times.sunrise);
            elNoon.innerText = formatTime(times.solarNoon);
            elSunset.innerText = formatTime(times.sunset);
            elDusk.innerText = formatTime(times.dusk);
            elIshaa.innerText = formatTime(times.night);
        }

        // --- Geolocation & Init ---

        function setDefaultLocation(msg) {
            locationStatus.innerHTML = `<span class="text-orange-400">‚ö†</span> ${msg} Using London.`;
            const now = new Date();
            updateSolarTimes(now);
            updateSunPosition(now);
            updateSunPath(now);
            updateSeasonLine(now);
            updateMoonPath(now);
            updateMoonPosition(now);
        }

        function init() {
            // Init Date Display
            // displayDateEl removed

            if ("geolocation" in navigator) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        userLat = position.coords.latitude;
                        userLon = position.coords.longitude;
                        locationStatus.innerHTML = `<span class="text-emerald-400">‚óè</span> ${userLat.toFixed(2)}, ${userLon.toFixed(2)}`;

                        const now = new Date();
                        updateSolarTimes(now);
                        updateSunPosition(now);
                        updateSunPath(now);
                        updateSeasonLine(now);
                        updateMoonPath(now);
                        updateMoonPosition(now);

                        updateMoonPosition(now);
                    },
                    (error) => {
                        let msg = "Location denied.";
                        if (error.message) msg = error.message;
                        console.log("Geolocation error:", msg);
                        setDefaultLocation(msg);
                    }
                );
            } else {
                setDefaultLocation("Geolocation not supported.");
            }
        }

        // --- Event Listeners ---

        function setTimeTo(date) {
            if (!date || date.toString() === 'Invalid Date') return;

            isManualMode = true; // Still useful to stop auto-sync with real time if we were doing that
            // But now we are mostly in manual mode anyway since we control speed


            currentDate = date;
            updateSunPosition(date);
            updateMoonPosition(date);

            resetBtn.classList.remove('bg-slate-600');
            resetBtn.classList.add('bg-indigo-600');
            resetBtn.innerText = "RESET TO NOW";
        }

        cardFajr.addEventListener('click', () => setTimeTo(SunCalc.getTimes(new Date(), userLat, userLon).nightEnd));
        cardDawn.addEventListener('click', () => setTimeTo(SunCalc.getTimes(new Date(), userLat, userLon).dawn));
        cardSunrise.addEventListener('click', () => setTimeTo(SunCalc.getTimes(new Date(), userLat, userLon).sunrise));
        cardNoon.addEventListener('click', () => setTimeTo(SunCalc.getTimes(new Date(), userLat, userLon).solarNoon));
        cardSunset.addEventListener('click', () => setTimeTo(SunCalc.getTimes(new Date(), userLat, userLon).sunset));
        cardDusk.addEventListener('click', () => setTimeTo(SunCalc.getTimes(new Date(), userLat, userLon).dusk));
        cardIshaa.addEventListener('click', () => setTimeTo(SunCalc.getTimes(new Date(), userLat, userLon).night));

        northIndicator.addEventListener('click', () => {
            // Set camera to top view (looking straight down)
            cameraElevation = Math.PI / 2;
            // Align north to the top of the screen (azimuth = 0 means camera looks from south towards north)
            cameraAzimuth = 0;
            updateCameraPosition();
        });

        citySelector.addEventListener('change', (e) => {
            const value = e.target.value;

            if (value === 'browser') {
                // Use browser location
                if ("geolocation" in navigator) {
                    locationStatus.innerHTML = `<span class="animate-pulse">‚óè</span> Locating...`;
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            userLat = position.coords.latitude;
                            userLon = position.coords.longitude;
                            locationStatus.innerHTML = `<span class="text-emerald-400">‚óè</span> ${userLat.toFixed(2)}, ${userLon.toFixed(2)}`;

                            updateSolarTimes(currentDate);
                            updateSunPosition(currentDate);
                            updateSunPath(currentDate);
                            updateSeasonLine(currentDate);
                            updateMoonPath(currentDate);
                            updateMoonPosition(currentDate);
                        },
                        (error) => {
                            locationStatus.innerHTML = `<span class="text-orange-400">‚ö†</span> Location denied`;
                            console.log("Geolocation error:", error);
                        }
                    );
                } else {
                    locationStatus.innerHTML = `<span class="text-orange-400">‚ö†</span> Geolocation not supported`;
                }
            } else {
                // Use selected city
                const [lat, lon] = value.split(',').map(parseFloat);
                userLat = lat;
                userLon = lon;

                const cityName = e.target.options[e.target.selectedIndex].text.split(' ').slice(1).join(' ');
                locationStatus.innerHTML = `<span class="text-emerald-400">‚óè</span> ${cityName}`;

                updateSolarTimes(currentDate);
                updateSunPosition(currentDate);
                updateSunPath(currentDate);
                updateSeasonLine(currentDate);
                updateMoonPath(currentDate);
                updateMoonPosition(currentDate);
            }
        });

        dateSlider.addEventListener('input', (e) => {
            isManualMode = true;
            dateSpeed = parseInt(e.target.value);

            resetBtn.classList.remove('bg-slate-600');
            resetBtn.classList.add('bg-indigo-600');
            resetBtn.innerText = "RESET TO NOW";
        });

        // Spring-back for Date Slider
        function resetDateSlider() {
            dateSlider.value = 0;
            dateSpeed = 0;
        }
        dateSlider.addEventListener('change', resetDateSlider);
        dateSlider.addEventListener('mouseup', resetDateSlider);
        dateSlider.addEventListener('touchend', resetDateSlider);


        todayBtn.addEventListener('click', () => {
            const now = new Date();
            // Keep current time, just change date
            currentDate.setFullYear(now.getFullYear(), now.getMonth(), now.getDate());

            updateSunPosition(currentDate);
            updateSolarTimes(currentDate);
            updateSunPath(currentDate);
            updateSeasonLine(currentDate);
            updateMoonPath(currentDate);
            updateMoonPosition(currentDate);
            // displayDateEl.innerText = currentDate.toLocaleDateString([], { month: 'short', day: 'numeric' });
        });

        timeSlider.addEventListener('input', (e) => {
            isManualMode = true;
            timeSpeed = parseInt(e.target.value);

            resetBtn.classList.remove('bg-slate-600');
            resetBtn.classList.add('bg-indigo-600');
            resetBtn.innerText = "RESET TO NOW";
        });

        // Spring-back for Time Slider
        function resetTimeSlider() {
            timeSlider.value = 0;
            timeSpeed = 0;
        }
        timeSlider.addEventListener('change', resetTimeSlider);
        timeSlider.addEventListener('mouseup', resetTimeSlider);
        timeSlider.addEventListener('touchend', resetTimeSlider);


        resetBtn.addEventListener('click', () => {
            isManualMode = false;
            const now = new Date();
            currentDate = now;

            // Update everything
            updateSunPosition(now);
            updateSolarTimes(now);
            updateSunPath(now);
            updateSeasonLine(now);
            updateMoonPath(now);
            updateMoonPosition(now);

            // displayDateEl.innerText = now.toLocaleDateString([], { month: 'short', day: 'numeric' });
            resetBtn.innerText = "LIVE";
        });

        window.addEventListener('resize', () => {
            const width = container.clientWidth;
            const height = container.clientHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        });

        // --- Animation Loop ---
        function animate(time) {
            requestAnimationFrame(animate);

            // Calculate delta time in seconds
            const nowTime = time * 0.001;
            const deltaTime = Math.min(nowTime - lastFrameTime, 0.1); // Cap at 0.1s to prevent huge jumps
            lastFrameTime = nowTime;

            let needsUpdate = false;
            let dateChanged = false;

            // Apply Time Speed
            if (timeSpeed !== 0) {
                // Exponential speed curve: 
                // 1-3: slow (minutes)
                // 4-7: medium (hours)
                // 8-10: fast (days)
                const sign = Math.sign(timeSpeed);
                const mag = Math.abs(timeSpeed);

                // Base speed in minutes per second
                let speedMinutesPerSec = 0;
                if (mag <= 3) speedMinutesPerSec = mag * 10; // 10, 20, 30 mins/sec
                else if (mag <= 7) speedMinutesPerSec = mag * 60; // 4-7 hours/sec equivalent
                else speedMinutesPerSec = mag * 60 * 10; // Very fast

                const minutesToAdd = speedMinutesPerSec * deltaTime * sign;
                // Use setTime for smooth float updates
                const msToAdd = minutesToAdd * 60 * 1000;
                currentDate.setTime(currentDate.getTime() + msToAdd);
                needsUpdate = true;
            }

            // Apply Date Speed
            if (dateSpeed !== 0) {
                const sign = Math.sign(dateSpeed);
                const mag = Math.abs(dateSpeed);

                // Days per second
                let speedDaysPerSec = 0;
                if (mag <= 3) speedDaysPerSec = mag * 2; // 2, 4, 6 days/sec
                else if (mag <= 7) speedDaysPerSec = mag * 10; // Faster
                else speedDaysPerSec = mag * 60; // Very fast (months/sec)

                // Accumulate fractional days
                dateAccumulator += speedDaysPerSec * deltaTime * sign;

                // Only apply integer days
                const daysToApply = Math.trunc(dateAccumulator);

                if (daysToApply !== 0) {
                    // Preserve time of day
                    const h = currentDate.getHours();
                    const m = currentDate.getMinutes();

                    currentDate.setDate(currentDate.getDate() + daysToApply);

                    // Restore time (handles DST shifts or other anomalies)
                    currentDate.setHours(h, m);

                    // Reduce accumulator by the amount we applied
                    dateAccumulator -= daysToApply;

                    needsUpdate = true;
                    dateChanged = true;
                }
            }

            // Live Mode (if no interaction)
            if (!isManualMode && timeSpeed === 0 && dateSpeed === 0) {
                const now = new Date();
                if (Math.abs(now - currentDate) > 1000) { // Sync if off by > 1s
                    currentDate = now;
                    needsUpdate = true;
                }
            }

            if (needsUpdate) {
                updateSunPosition(currentDate);
                updateMoonPosition(currentDate);
                // displayDateEl.innerText = currentDate.toLocaleDateString([], { month: 'short', day: 'numeric' });

                // Only update expensive paths if date changed significantly (e.g. by more than a day total diff from last path update)
                // For now, let's just update them if dateSpeed is active or if day changed
                if (dateChanged || Math.abs(dateSpeed) > 0) {
                    // Throttle path updates? 
                    // Actually, updating geometry every frame is heavy. 
                    // Let's only update if the day integer has changed.
                    // We can store lastPathDate.
                }
            }

            // Optimization: Check if day changed for path updates
            if (!window.lastPathDate || currentDate.getDate() !== window.lastPathDate.getDate() || currentDate.getMonth() !== window.lastPathDate.getMonth()) {
                updateSunPath(currentDate);
                updateSeasonLine(currentDate);
                updateMoonPath(currentDate);
                updateSolarTimes(currentDate);
                window.lastPathDate = new Date(currentDate);
            }

            renderer.render(scene, camera);
        }

        // Wait for libraries
        window.onload = function () {
            if (typeof SunCalc !== 'undefined' && typeof THREE !== 'undefined') {
                init();
                animate();
            } else {
                locationStatus.innerText = "Error loading libraries.";
            }
        };

    </script>
</body>

</html>